# TCP/IP相关内核数据结构-1

参看：

- [linux内核TCP/IP源码浅析](https://blog.csdn.net/weixin_40355471/article/details/131535653)


在tcp/ip协议栈中，sk_buff是一个关键的数据结构，通过其可以分别获得tcphdr、iphdr、ethhdr三个协议头：

```c
//include/linux/tcp.h
static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)

//include/linux/ip.h
static inline struct iphdr *ip_hdr(const struct sk_buff *skb)

//include/linux/if_ether.h
static inline struct ethhdr *eth_hdr(const struct sk_buff *skb)
```

## 1. ethhdr数据结构

我们可以在include/uapi/linux/if_ether.h找到ethhdr结构的定义：

```c
/*
 *	This is an Ethernet frame header.
 */

/* allow libcs like musl to deactivate this, glibc does not implement this. */
#ifndef __UAPI_DEF_ETHHDR
#define __UAPI_DEF_ETHHDR		1
#endif

#if __UAPI_DEF_ETHHDR
struct ethhdr {
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	__be16		h_proto;		/* packet type ID field	*/
} __attribute__((packed));
#endif
```


## 2. iphdr数据结构

参看:

- [IP头部详解](https://zhuanlan.zhihu.com/p/371723473)

- [IPv4 协议解析](https://sunyunqiang.com/blog/ipv4_protocol_rfc791/)

- [IPv4 RFC](https://www.rfc-editor.org/rfc/inline-errata/rfc791.html)

- [ipv4-packet-header](https://networklessons.com/cisco/ccna-routing-switching-icnd1-100-105/ipv4-packet-header)

- [IP分片与重组](https://www.cnblogs.com/guoxiaoyu/p/17734623.html)

- [浅谈IP数据报分片与重组](https://blog.csdn.net/chen1415886044/article/details/120471364)

我们可以在include/uapi/linux/ip.h找到iphdr的定义：

```c
struct iphdr {
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	ihl:4,
		version:4;
#elif defined (__BIG_ENDIAN_BITFIELD)
	__u8	version:4,
  		ihl:4;
#else
#error	"Please fix <asm/byteorder.h>"
#endif
	__u8	tos;
	__be16	tot_len;
	__be16	id;
	__be16	frag_off;
	__u8	ttl;
	__u8	protocol;
	__sum16	check;
	__struct_group(/* no tag */, addrs, /* no attrs */,
		__be32	saddr;
		__be32	daddr;
	);
	/*The options start here. */
};
```

这里我们先给出一张IP协议头的图片:

![IPHeader](https://raw.githubusercontent.com/ivanzz1001/protocol_development_learning/master/tcp/sourcecode/image/tcpip-10001-01.png)

接下来我们简单介绍一下各字段的含义：

1. `ihl`、`version`字段

    - `ihl`占用4个bit。这个字段的作用是为了描述IP包头的长度，这是因为在IP包头中有变长的可选部分。4个bit位可表示的范围是[0, 15]，其单位是4字节，因此实际实际可表示的字节范围是[0, 60]。IP包头的最小长度是20。
    - `version`占用4个bit，用于指示版本号.

1. `tos`: 服务类型字段

1. `tot_len`: IP包总长度，用2字节表示。 以字节为单位计算的IP包的长度 (包括头部和数据)，所以IP包最大长度65535字节。

1. `id`: 长度16比特。该字段Fragment Offest字段联合使用，对较大的上层数据包进行分段（fragment）操作。路由器将一个包拆分后，所有拆分开的小包被标记相同的值，以便目的端设备能够区分哪个包属于被拆分开的包的一部分。

1. `frag_off`: 本字段其实可以拆分为flags和fragment_offset两部分
    - `flag`部分： 长度3比特。该字段第一位不使用。第二位是DF（Don't Fragment）位，DF位设为1时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。第三位是MF（More Fragments）位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的IP包的包头中将MF位设为1

    - `frament_offset`: 片偏移，长度13比特。表示该IP包在该组分片包中位置，接收端靠此来组装还原IP包。

1. `ttl`: 长度8比特。当IP包进行传送时，先会对该字段赋予某个特定的值。当IP包经过每一个沿途的路由器的时候，每个沿途的路由器会将IP包的TTL值减少1。如果TTL减少为0，则该IP包会被丢弃。这个字段可以防止由于路由环路而导致IP包在网络中不停被转发。

1. `protocol`: 协议字段，占用8个字节。标识了上层所使用的协议。我们可以在`tools/include/uapi/linux/in.h`找到所支持的所有协议，以下是一些比较常用的协议号：
    - ICMP
    - IGMP
    - TCP
    - UDP
    - IGRP
    - OSPF

1. `check`: 首部校验和字段。长度16位。用来做IP头部的正确性检测，但不包含数据部分。 因为每个路由器要改变TTL的值,所以路由器会为每个通过的数据包重新计算这个值

1. `saddr`、`daddr`: 分别指示32位的源地址和目的地址
     >ps: 对于saddr/daddr， 除非使用NAT，否则整个传输的过程中，这两个地址不会改变

对于`__struct_group`标识符的定义，我们可以在include/uapi/linux/stddef.h找到：

```c
/**
 * __struct_group() - Create a mirrored named and anonyomous struct
 *
 * @TAG: The tag name for the named sub-struct (usually empty)
 * @NAME: The identifier name of the mirrored sub-struct
 * @ATTRS: Any struct attributes (usually empty)
 * @MEMBERS: The member declarations for the mirrored structs
 *
 * Used to create an anonymous union of two structs with identical layout
 * and size: one anonymous and one named. The former's members can be used
 * normally without sub-struct naming, and the latter can be used to
 * reason about the start, end, and size of the group of struct members.
 * The named struct can also be explicitly tagged for layer reuse, as well
 * as both having struct attributes appended.
 */
#define __struct_group(TAG, NAME, ATTRS, MEMBERS...) \
	union { \
		struct { MEMBERS } ATTRS; \
		struct TAG { MEMBERS } ATTRS NAME; \
	} ATTRS
```

## 3. tcphdr数据结构

参看:

- [熟悉TCP报头结构并理解三次握手与四次挥手](https://blog.csdn.net/JLX_1/article/details/142934023)

- [tcp-rfc](https://www.rfc-editor.org/rfc/rfc9293.html)

- [TCP报文头（首部）详解](https://blog.csdn.net/ShenDaiSun/article/details/134960302)

我们可以在include/uapi/linux/tcp.h找到其定义如下：

```c
struct tcphdr {
	__be16	source;
	__be16	dest;
	__be32	seq;
	__be32	ack_seq;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u16	res1:4,
		doff:4,
		fin:1,
		syn:1,
		rst:1,
		psh:1,
		ack:1,
		urg:1,
		ece:1,
		cwr:1;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u16	doff:4,
		res1:4,
		cwr:1,
		ece:1,
		urg:1,
		ack:1,
		psh:1,
		rst:1,
		syn:1,
		fin:1;
#else
#error	"Adjust your <asm/byteorder.h> defines"
#endif
	__be16	window;
	__sum16	check;
	__be16	urg_ptr;
};
```
从上面我们可以看到tcp头一般情况下占用20个字节，如下图所示:

![IPHeader](https://raw.githubusercontent.com/ivanzz1001/protocol_development_learning/master/tcp/sourcecode/image/tcpip-10001-02.png)

### 3.1 关键字段解析
1. `source`、`dest`
分别为16位的源端口及目的端口

1. `seq`、`ack_seq`
这两个字段用于指示发送包的序列号与响应包的序列号。

1. `doff`
长度为4位，指示TCP报文的“数据”起始处距离TCP报文起始处的距离有多远，以4字节为单位计算出的数据段开始地址的偏移值。没有选项时该值为5，即20字节；4位能表示的最大整数是15，也就说明TCP报文里数据开始的位置距离报文起点是60个字节(4*15)。这意味着TCP的首部长度是20-60个字节

1. 控制标志
长度为9位，用于控制和管理TCP连接。各控制标志位说明如下：
    - `CWR`: 即Congestion Window Reduced,用于指示发送方减小拥塞窗口(Congestion Window)的大小。CWR标志位通常与拥塞控制机制一起使用，以应对网络拥塞的情况
    - `ECE`: ECE标志被设置表示发送方支持显式拥塞通知(Explicit Congestion Notification, ECN)机制，并请求接收方通知其关于网络拥塞的情况。接收方在收到设置了ECE标志的TCP报文段后，如果网络出现拥塞，则可以在回复的TCP报文段中设置ECN-Echo标志作为响应。通过使用ECE标志和ECN-Echo回复，TCP连接的发送方和接收方可以共同协调拥塞控制，以提高网络的性能和稳定性。
    - `URG`：紧急指针是否有效
    - `ACK`：确认号是否有效
    - `PSH`：提示接收端应用程序立刻从TCP缓冲区把数据读走
    - `RST`：对方要求重新建立连接；我们把携带RST标识的称为复位报文段
    - `SYN`：请求建立连接；我们把携带SYN标识的称为同步报文段
    - `FIN`：通知对方，本端要关闭了，我们称携带FIN标识的为结束报文段

1. `window`
    长度为16位，指示接收方的接收窗口大小，用于流量控制，最大的窗口大小为2^16-1=65535=64k。这是早期的设计，对于现在的网络应用，可能会不太够，因此可以在选项里加一个 窗口扩大选项，来传输更多的数据。窗口指的是发送本报文段一方的接受窗口(而不是自己的发送窗口)。

    窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量(以字节为单位)。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。

    >ps:TCP option中的有窗口扩大因子字段，占用3字节，取值0-14。用来把TCP的窗口的值左移的位数，使窗口值乘倍。只能出现在同步报文段中，否则将被忽略。这是因为现在的TCP接收数据缓冲区(接收窗口)的长度通常大于65535字节。

1. `check`
长度为16位，用于检测TCP报文段是否在传输过程中发生了错误。校验和计算包括报头和数据。

1. `urg_ptr`
长度为16位，只有在URG标志位被设置时才有效。它指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据)。

### 3.2 tcp header头中的选项部分
可选字段，长度可变，最长可达40个字节。当没有使用“选项”时，TCP的首部长度是20字节。选项字段用于提供额外的功能和控制，每个选项的开始是 1 字节的kind字段，说明选项的类型。

![IPHeader](https://raw.githubusercontent.com/ivanzz1001/protocol_development_learning/master/tcp/sourcecode/image/tcpip-10001-03.png)

1. `MSS` 
最大报文段长度(Maximum Segment Size, MSS)，kind值为2，占用4字节，通常在创建连接而设置SYN标志的数据包中指明这个选项，指明本端所能接收的最大长度的报文段。通常将MSS设置为(MTU-40)字节，携带TCP报文段的IP数据报的长度就不会超过MTU(MTU最大长度为1518字节，最短为64字节)，从而避免本机发生IP分片。只能出现在同步报文段中，否则将被忽略

1. 窗口扩大因子
占用3字节，取值0-14。用来把TCP的窗口的值左移的位数，使窗口值乘倍。只能出现在同步报文段中，否则将被忽略。这是因为现在的TCP接收数据缓冲区(接收窗口)的长度通常大于65535字节。

1. 时间戳选项(TCP Timestamps Option, TSopt)
占用10字节，其中最主要的字段是时间戳字段(Timestamp Value field, TSval, 4字节)和时间戳回送回答字段(Timestamp Echo Reply field, TSecr, 4字节)。时间戳选项允许通信的两端在TCP报文段中包含时间戳值，以便进行一些时间相关的操作和计算。

1. 安全摘要选项(TCP Authentication Option, TCP Option)
用于提供数据完整性和身份验证的功能。该选项用于对TCP报文段进行保护，防止数据篡改和未经授权的访问
